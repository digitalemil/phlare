package k8s

import (
	"crypto/tls"
	"crypto/x509"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net"
	"net/http"
	url2 "net/url"
	"os"
	"strings"
)

type Target map[string]string

type Client struct {
	nodeName string

	liteClient *http.Client

	liteHost  string
	liteToken string
}

func New(node string) (*Client, error) {
	//httpClient, err := rest.HTTPClientFor(config)
	//if err != nil {
	//	panic(err)
	//}
	//k8sHttpClient = httpClient
	host, port := os.Getenv("KUBERNETES_SERVICE_HOST"), os.Getenv("KUBERNETES_SERVICE_PORT")
	if len(host) == 0 || len(port) == 0 {
		return nil, fmt.Errorf("NOT IN CLUSTER")
	}

	liteClient := http.DefaultClient
	liteHost := "https://" + net.JoinHostPort(host, port)

	// If your setup requires certificate verification,
	// load the CA and add it to the http client's Transport
	// You might also need to configure client certificate if needed
	const (
		tokenFile  = "/var/run/secrets/kubernetes.io/serviceaccount/token"
		rootCAFile = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
	)
	caCert, err := ioutil.ReadFile(rootCAFile)
	if err != nil {
		return nil, err
	}
	token, err := ioutil.ReadFile(tokenFile)
	if err != nil {
		return nil, err
	}

	caCertPool := x509.NewCertPool()
	caCertPool.AppendCertsFromPEM(caCert)

	// Create a custom HTTP client with the CA pool
	client := &http.Client{
		Transport: &http.Transport{
			TLSClientConfig: &tls.Config{
				RootCAs: caCertPool,
			},
		},
	}
	liteClient = client
	liteToken := string(token)
	return &Client{
		nodeName:   node,
		liteClient: liteClient,
		liteHost:   liteHost,
		liteToken:  liteToken,
	}, nil
}

// PodList is a list of Pods.
type PodList struct {
	//metav1.TypeMeta `json:",inline"`
	//// Standard list metadata.
	//// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	//// +optional
	//metav1.ListMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`

	// List of pods.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
	Items []Pod `json:"items" protobuf:"bytes,2,rep,name=items"`
}

type ObjectMeta struct {
	// Name must be unique within a namespace. Is required when creating resources, although
	// some resources may allow a client to request the generation of an appropriate name
	// automatically. Name is primarily intended for creation idempotence and configuration
	// definition.
	// Cannot be updated.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
	// +optional
	Name string `json:"name,omitempty" protobuf:"bytes,1,opt,name=name"`

	//// GenerateName is an optional prefix, used by the server, to generate a unique
	//// name ONLY IF the Name field has not been provided.
	//// If this field is used, the name returned to the client will be different
	//// than the name passed. This value will also be combined with a unique suffix.
	//// The provided value has the same validation rules as the Name field,
	//// and may be truncated by the length of the suffix required to make the value
	//// unique on the server.
	////
	//// If this field is specified and the generated name exists, the server will return a 409.
	////
	//// Applied only if Name is not specified.
	//// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
	//// +optional
	//GenerateName string `json:"generateName,omitempty" protobuf:"bytes,2,opt,name=generateName"`
	//
	//// Namespace defines the space within which each name must be unique. An empty namespace is
	//// equivalent to the "default" namespace, but "default" is the canonical representation.
	//// Not all objects are required to be scoped to a namespace - the value of this field for
	//// those objects will be empty.
	////
	//// Must be a DNS_LABEL.
	//// Cannot be updated.
	//// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces
	//// +optional
	Namespace string `json:"namespace,omitempty" protobuf:"bytes,3,opt,name=namespace"`
	//
	//// Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
	//// +optional
	//SelfLink string `json:"selfLink,omitempty" protobuf:"bytes,4,opt,name=selfLink"`
	//
	//// UID is the unique in time and space value for this object. It is typically generated by
	//// the server on successful creation of a resource and is not allowed to change on PUT
	//// operations.
	////
	//// Populated by the system.
	//// Read-only.
	//// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
	//// +optional
	//UID types.UID `json:"uid,omitempty" protobuf:"bytes,5,opt,name=uid,casttype=k8s.io/kubernetes/pkg/types.UID"`
	//
	//// An opaque value that represents the internal version of this object that can
	//// be used by clients to determine when objects have changed. May be used for optimistic
	//// concurrency, change detection, and the watch operation on a resource or set of resources.
	//// Clients must treat these values as opaque and passed unmodified back to the server.
	//// They may only be valid for a particular resource or set of resources.
	////
	//// Populated by the system.
	//// Read-only.
	//// Value must be treated as opaque by clients and .
	//// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
	//// +optional
	//ResourceVersion string `json:"resourceVersion,omitempty" protobuf:"bytes,6,opt,name=resourceVersion"`
	//
	//// A sequence number representing a specific generation of the desired state.
	//// Populated by the system. Read-only.
	//// +optional
	//Generation int64 `json:"generation,omitempty" protobuf:"varint,7,opt,name=generation"`
	//
	//// CreationTimestamp is a timestamp representing the server time when this object was
	//// created. It is not guaranteed to be set in happens-before order across separate operations.
	//// Clients may not set this value. It is represented in RFC3339 form and is in UTC.
	////
	//// Populated by the system.
	//// Read-only.
	//// Null for lists.
	//// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	//// +optional
	//CreationTimestamp Time `json:"creationTimestamp,omitempty" protobuf:"bytes,8,opt,name=creationTimestamp"`
	//
	//// DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
	//// field is set by the server when a graceful deletion is requested by the user, and is not
	//// directly settable by a client. The resource is expected to be deleted (no longer visible
	//// from resource lists, and not reachable by name) after the time in this field, once the
	//// finalizers list is empty. As long as the finalizers list contains items, deletion is blocked.
	//// Once the deletionTimestamp is set, this value may not be unset or be set further into the
	//// future, although it may be shortened or the resource may be deleted prior to this time.
	//// For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react
	//// by sending a graceful termination signal to the containers in the pod. After that 30 seconds,
	//// the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup,
	//// remove the pod from the API. In the presence of network partitions, this object may still
	//// exist after this timestamp, until an administrator or automated process can determine the
	//// resource is fully terminated.
	//// If not set, graceful deletion of the object has not been requested.
	////
	//// Populated by the system when a graceful deletion is requested.
	//// Read-only.
	//// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	//// +optional
	//DeletionTimestamp *Time `json:"deletionTimestamp,omitempty" protobuf:"bytes,9,opt,name=deletionTimestamp"`
	//
	//// Number of seconds allowed for this object to gracefully terminate before
	//// it will be removed from the system. Only set when deletionTimestamp is also set.
	//// May only be shortened.
	//// Read-only.
	//// +optional
	//DeletionGracePeriodSeconds *int64 `json:"deletionGracePeriodSeconds,omitempty" protobuf:"varint,10,opt,name=deletionGracePeriodSeconds"`
	//
	//// Map of string keys and values that can be used to organize and categorize
	//// (scope and select) objects. May match selectors of replication controllers
	//// and services.
	//// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
	//// +optional
	Labels map[string]string `json:"labels,omitempty" protobuf:"bytes,11,rep,name=labels"`
	//
	//// Annotations is an unstructured key value map stored with a resource that may be
	//// set by external tools to store and retrieve arbitrary metadata. They are not
	//// queryable and should be preserved when modifying objects.
	//// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
	//// +optional
	//Annotations map[string]string `json:"annotations,omitempty" protobuf:"bytes,12,rep,name=annotations"`
	//
	//// List of objects depended by this object. If ALL objects in the list have
	//// been deleted, this object will be garbage collected. If this object is managed by a controller,
	//// then an entry in this list will point to this controller, with the controller field set to true.
	//// There cannot be more than one managing controller.
	//// +optional
	//// +patchMergeKey=uid
	//// +patchStrategy=merge
	//OwnerReferences []OwnerReference `json:"ownerReferences,omitempty" patchStrategy:"merge" patchMergeKey:"uid" protobuf:"bytes,13,rep,name=ownerReferences"`
	//
	//// Must be empty before the object is deleted from the registry. Each entry
	//// is an identifier for the responsible component that will remove the entry
	//// from the list. If the deletionTimestamp of the object is non-nil, entries
	//// in this list can only be removed.
	//// Finalizers may be processed and removed in any order.  Order is NOT enforced
	//// because it introduces significant risk of stuck finalizers.
	//// finalizers is a shared field, any actor with permission can reorder it.
	//// If the finalizer list is processed in order, then this can lead to a situation
	//// in which the component responsible for the first finalizer in the list is
	//// waiting for a signal (field value, external system, or other) produced by a
	//// component responsible for a finalizer later in the list, resulting in a deadlock.
	//// Without enforced ordering finalizers are free to order amongst themselves and
	//// are not vulnerable to ordering changes in the list.
	//// +optional
	//// +patchStrategy=merge
	//Finalizers []string `json:"finalizers,omitempty" patchStrategy:"merge" protobuf:"bytes,14,rep,name=finalizers"`
	//
	//// Tombstone: ClusterName was a legacy field that was always cleared by
	//// the system and never used.
	//// ClusterName string `json:"clusterName,omitempty" protobuf:"bytes,15,opt,name=clusterName"`
	//
	//// ManagedFields maps workflow-id and version to the set of fields
	//// that are managed by that workflow. This is mostly for internal
	//// housekeeping, and users typically shouldn't need to set or
	//// understand this field. A workflow can be the user's name, a
	//// controller's name, or the name of a specific apply path like
	//// "ci-cd". The set of fields is always in the version that the
	//// workflow used when modifying the object.
	////
	//// +optional
	//ManagedFields []ManagedFieldsEntry `json:"managedFields,omitempty" protobuf:"bytes,17,rep,name=managedFields"`
}

type Pod struct {
	//metav1.TypeMeta `json:",inline"`
	//// Standard object's metadata.
	//// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	//// +optional
	ObjectMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
	//
	//// Specification of the desired behavior of the pod.
	//// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	//// +optional
	//Spec PodSpec `json:"spec,omitempty" protobuf:"bytes,2,opt,name=spec"`

	// Most recently observed status of the pod.
	// This data may not be up to date.
	// Populated by the system.
	// Read-only.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	// +optional
	Status PodStatus `json:"status,omitempty" protobuf:"bytes,3,opt,name=status"`
}

type PodStatus struct {
	// The phase of a Pod is a simple, high-level summary of where the Pod is in its lifecycle.
	// The conditions array, the reason and message fields, and the individual container status
	// arrays contain more detail about the pod's status.
	// There are five possible phase values:
	//
	// Pending: The pod has been accepted by the Kubernetes system, but one or more of the
	// container images has not been created. This includes time before being scheduled as
	// well as time spent downloading images over the network, which could take a while.
	// Running: The pod has been bound to a node, and all of the containers have been created.
	// At least one container is still running, or is in the process of starting or restarting.
	// Succeeded: All containers in the pod have terminated in success, and will not be restarted.
	// Failed: All containers in the pod have terminated, and at least one container has
	// terminated in failure. The container either exited with non-zero status or was terminated
	// by the system.
	// Unknown: For some reason the state of the pod could not be obtained, typically due to an
	// error in communicating with the host of the pod.
	//
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-phase
	//// +optional
	//Phase PodPhase `json:"phase,omitempty" protobuf:"bytes,1,opt,name=phase,casttype=PodPhase"`
	//// Current service state of pod.
	//// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
	//// +optional
	//// +patchMergeKey=type
	//// +patchStrategy=merge
	//Conditions []PodCondition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,2,rep,name=conditions"`
	//// A human readable message indicating details about why the pod is in this condition.
	//// +optional
	//Message string `json:"message,omitempty" protobuf:"bytes,3,opt,name=message"`
	//// A brief CamelCase message indicating details about why the pod is in this state.
	//// e.g. 'Evicted'
	//// +optional
	//Reason string `json:"reason,omitempty" protobuf:"bytes,4,opt,name=reason"`
	//// nominatedNodeName is set only when this pod preempts other pods on the node, but it cannot be
	//// scheduled right away as preemption victims receive their graceful termination periods.
	//// This field does not guarantee that the pod will be scheduled on this node. Scheduler may decide
	//// to place the pod elsewhere if other nodes become available sooner. Scheduler may also decide to
	//// give the resources on this node to a higher priority pod that is created after preemption.
	//// As a result, this field may be different than PodSpec.nodeName when the pod is
	//// scheduled.
	//// +optional
	//NominatedNodeName string `json:"nominatedNodeName,omitempty" protobuf:"bytes,11,opt,name=nominatedNodeName"`
	//
	//// IP address of the host to which the pod is assigned. Empty if not yet scheduled.
	//// +optional
	//HostIP string `json:"hostIP,omitempty" protobuf:"bytes,5,opt,name=hostIP"`
	//// IP address allocated to the pod. Routable at least within the cluster.
	//// Empty if not yet allocated.
	//// +optional
	//PodIP string `json:"podIP,omitempty" protobuf:"bytes,6,opt,name=podIP"`
	//
	//// podIPs holds the IP addresses allocated to the pod. If this field is specified, the 0th entry must
	//// match the podIP field. Pods may be allocated at most 1 value for each of IPv4 and IPv6. This list
	//// is empty if no IPs have been allocated yet.
	//// +optional
	//// +patchStrategy=merge
	//// +patchMergeKey=ip
	//PodIPs []PodIP `json:"podIPs,omitempty" protobuf:"bytes,12,rep,name=podIPs" patchStrategy:"merge" patchMergeKey:"ip"`
	//
	//// RFC 3339 date and time at which the object was acknowledged by the Kubelet.
	//// This is before the Kubelet pulled the container image(s) for the pod.
	//// +optional
	//StartTime *metav1.Time `json:"startTime,omitempty" protobuf:"bytes,7,opt,name=startTime"`
	//
	//// The list has one entry per init container in the manifest. The most recent successful
	//// init container will have ready = true, the most recently started container will have
	//// startTime set.
	//// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
	//InitContainerStatuses []ContainerStatus `json:"initContainerStatuses,omitempty" protobuf:"bytes,10,rep,name=initContainerStatuses"`

	// The list has one entry per container in the manifest.
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
	// +optional
	ContainerStatuses []ContainerStatus `json:"containerStatuses,omitempty" protobuf:"bytes,8,rep,name=containerStatuses"`
	// The Quality of Service (QOS) classification assigned to the pod based on resource requirements
	// See PodQOSClass type for available QOS classes
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-qos/#quality-of-service-classes
	// +optional
	//QOSClass PodQOSClass `json:"qosClass,omitempty" protobuf:"bytes,9,rep,name=qosClass"`
	//// Status for any ephemeral containers that have run in this pod.
	//// +optional
	//EphemeralContainerStatuses []ContainerStatus `json:"ephemeralContainerStatuses,omitempty" protobuf:"bytes,13,rep,name=ephemeralContainerStatuses"`
	//
	//// Status of resources resize desired for pod's containers.
	//// It is empty if no resources resize is pending.
	//// Any changes to container resources will automatically set this to "Proposed"
	//// +featureGate=InPlacePodVerticalScaling
	//// +optional
	//Resize PodResizeStatus `json:"resize,omitempty" protobuf:"bytes,14,opt,name=resize,casttype=PodResizeStatus"`
}

type ContainerStatus struct {
	//// Name is a DNS_LABEL representing the unique name of the container.
	//// Each container in a pod must have a unique name across all container types.
	//// Cannot be updated.
	Name string `json:"name" protobuf:"bytes,1,opt,name=name"`
	//// State holds details about the container's current condition.
	//// +optional
	//State ContainerState `json:"state,omitempty" protobuf:"bytes,2,opt,name=state"`
	//// LastTerminationState holds the last termination state of the container to
	//// help debug container crashes and restarts. This field is not
	//// populated if the container is still running and RestartCount is 0.
	//// +optional
	//LastTerminationState ContainerState `json:"lastState,omitempty" protobuf:"bytes,3,opt,name=lastState"`
	//// Ready specifies whether the container is currently passing its readiness check.
	//// The value will change as readiness probes keep executing. If no readiness
	//// probes are specified, this field defaults to true once the container is
	//// fully started (see Started field).
	////
	//// The value is typically used to determine whether a container is ready to
	//// accept traffic.
	//Ready bool `json:"ready" protobuf:"varint,4,opt,name=ready"`
	//// RestartCount holds the number of times the container has been restarted.
	//// Kubelet makes an effort to always increment the value, but there
	//// are cases when the state may be lost due to node restarts and then the value
	//// may be reset to 0. The value is never negative.
	//RestartCount int32 `json:"restartCount" protobuf:"varint,5,opt,name=restartCount"`
	//// Image is the name of container image that the container is running.
	//// The container image may not match the image used in the PodSpec,
	//// as it may have been resolved by the runtime.
	//// More info: https://kubernetes.io/docs/concepts/containers/images.
	//Image string `json:"image" protobuf:"bytes,6,opt,name=image"`
	//// ImageID is the image ID of the container's image. The image ID may not
	//// match the image ID of the image used in the PodSpec, as it may have been
	//// resolved by the runtime.
	//ImageID string `json:"imageID" protobuf:"bytes,7,opt,name=imageID"`
	//// ContainerID is the ID of the container in the format '<type>://<container_id>'.
	//// Where type is a container runtime identifier, returned from Version call of CRI API
	//// (for example "containerd").
	//// +optional
	ContainerID string `json:"containerID,omitempty" protobuf:"bytes,8,opt,name=containerID"`
	//// Started indicates whether the container has finished its postStart lifecycle hook
	//// and passed its startup probe.
	//// Initialized as false, becomes true after startupProbe is considered
	//// successful. Resets to false when the container is restarted, or if kubelet
	//// loses state temporarily. In both cases, startup probes will run again.
	//// Is always true when no startupProbe is defined and container is running and
	//// has passed the postStart lifecycle hook. The null value must be treated the
	//// same as false.
	//// +optional
	//Started *bool `json:"started,omitempty" protobuf:"varint,9,opt,name=started"`
	//// AllocatedResources represents the compute resources allocated for this container by the
	//// node. Kubelet sets this value to Container.Resources.Requests upon successful pod admission
	//// and after successfully admitting desired pod resize.
	//// +featureGate=InPlacePodVerticalScaling
	//// +optional
	//AllocatedResources ResourceList `json:"allocatedResources,omitempty" protobuf:"bytes,10,rep,name=allocatedResources,casttype=ResourceList,castkey=ResourceName"`
	//// Resources represents the compute resource requests and limits that have been successfully
	//// enacted on the running container after it has been started or has been successfully resized.
	//// +featureGate=InPlacePodVerticalScaling
	//// +optional
	//Resources *ResourceRequirements `json:"resources,omitempty" protobuf:"bytes,11,opt,name=resources"`
}

func (c *Client) getTargets(pods *PodList) []Target {
	var targets []Target

	for _, pod := range pods.Items {
		for _, status := range pod.Status.ContainerStatuses {
			if status.ContainerID == "" {
				fmt.Printf("Unknown containerID for pod %v, status %v", pod, status)
				continue
			}
			cid, err := getContainerIDFromK8S(status.ContainerID)
			if err != nil {
				panic(err)
			}
			ls := make(map[string]string)
			ls["node"] = c.nodeName
			ls["pod"] = pod.Name
			ls["namespace"] = pod.Namespace
			ls["__meta_kubernetes_namespace"] = pod.Namespace
			ls["__meta_kubernetes_pod_container_name"] = status.Name
			ls["__container_id__"] = cid
			ls["container_name"] = status.Name
			//if v, ok := pod.Labels["app.kubernetes.io/name"]; ok {
			//	ls["app_kubernetes_io_name"] = v
			//}
			//if v, ok := pod.Labels["app.kubernetes.io/version"]; ok {
			//	ls["app_kubernetes_io_version"] = v
			//}
			//if v, ok := pod.Labels["app.kubernetes.io/instance"]; ok {
			//	ls["app_kubernetes_io_instance"] = v
			//}
			//sd.containerID2Labels[cid] = ls
			targets = append(targets, ls)
		}
	}
	return targets
}

func (c *Client) GetTargetsLite() ([]Target, error) {
	u, err := url2.Parse(c.liteHost)
	if err != nil {
		return nil, err
	}
	u.Path = "/api/v1/pods"
	q := u.Query()
	q.Set("fieldSelector", "spec.nodeName="+c.nodeName)
	//url := config.Host + "/api/v1/pods?fieldSelector=spec.nodeName=" + nodeName
	u.RawQuery = q.Encode()
	url := u.String()
	_ = url

	req, _ := http.NewRequest("GET", url, nil)

	bearer := "Bearer " + c.liteToken
	//fmt.Println(bearer)

	// Add the bearer token to the request's header
	req.Header.Add("Authorization", bearer)

	resp, err := c.liteClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	podList := &PodList{}
	dec := json.NewDecoder(resp.Body)
	if err := dec.Decode(podList); err == io.EOF {

	} else if err != nil {
		return nil, err
	}

	return c.getTargets(podList), nil
}

var knownContainerIDPrefixes = []string{"docker://", "containerd://", "cri-o://"}
var knownRuntimes = []string{"docker://", "containerd://"}

func getContainerIDFromK8S(k8sContainerID string) (string, error) {
	for _, p := range knownContainerIDPrefixes {
		if strings.HasPrefix(k8sContainerID, p) {
			return strings.TrimPrefix(k8sContainerID, p), nil
		}
	}
	return "", fmt.Errorf("unknown container id %s", k8sContainerID)
}
